From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: etil2jz <blanchot.arthur@protonmail.ch>
Date: Wed, 20 Apr 2022 13:03:37 +0200
Subject: [PATCH] c2me: worldgen vanilla bugs fixes

Author: ishland <ishlandmc@yeah.net>

Original license: MIT
Original project: https://github.com/RelativityMC/C2ME-fabric (Yarn mappings)

Copyright (c) 2021-2022 ishland

diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
index 954e141e5617d6d52e2f3008c25fe9e2fe2f0f9a..05520be9696ee2a400735a69ed1151bebcf6e3c7 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -5,6 +5,7 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntList;
+import java.util.ArrayList; // Mirai - c2me: worldgen vanilla bugs fixes
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
@@ -170,7 +171,7 @@ public class ChunkStatus {
     }, (chunkstatus, worldserver, definedstructuremanager, lightenginethreaded, function, ichunkaccess) -> {
         return (CompletableFuture) function.apply(ichunkaccess);
     });
-    private static final List<ChunkStatus> STATUS_BY_RANGE = ImmutableList.of(ChunkStatus.FULL, ChunkStatus.FEATURES, ChunkStatus.LIQUID_CARVERS, ChunkStatus.BIOMES, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, new ChunkStatus[0]);
+    private static List<ChunkStatus> STATUS_BY_RANGE = ImmutableList.of(ChunkStatus.FULL, ChunkStatus.FEATURES, ChunkStatus.LIQUID_CARVERS, ChunkStatus.BIOMES, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, new ChunkStatus[0]); // Mirai - remove final
     private static final IntList RANGE_BY_STATUS = (IntList) Util.make(new IntArrayList(ChunkStatus.getStatusList().size()), (intarraylist) -> {
         int i = 0;
 
@@ -352,4 +353,12 @@ public class ChunkStatus {
 
         void doWork(ChunkStatus targetStatus, ServerLevel world, ChunkGenerator chunkGenerator, List<ChunkAccess> chunks, ChunkAccess chunk);
     }
+
+    // Mirai start - c2me: worldgen vanilla bugs fixes
+    static {
+        final List<ChunkStatus> distanceToStatus = new ArrayList<>(STATUS_BY_RANGE);
+        distanceToStatus.add(ChunkStatus.STRUCTURE_STARTS);
+        STATUS_BY_RANGE = ImmutableList.copyOf(distanceToStatus);
+    }
+    // Mirai end
 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/placement/PlacedFeature.java b/src/main/java/net/minecraft/world/level/levelgen/placement/PlacedFeature.java
index 327f723e8f9e482cdaed4b77fdb4c3b5bc5a4a54..94bc393a388c632fad2e1b845e36790a37c8feb3 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/placement/PlacedFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/placement/PlacedFeature.java
@@ -1,71 +1,101 @@
-package net.minecraft.world.level.levelgen.placement;
-
-import com.mojang.serialization.Codec;
-import com.mojang.serialization.codecs.RecordCodecBuilder;
-import java.util.List;
-import java.util.Optional;
-import java.util.Random;
-import java.util.stream.Stream;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
-import net.minecraft.core.HolderSet;
-import net.minecraft.core.Registry;
-import net.minecraft.core.RegistryCodecs;
-import net.minecraft.resources.RegistryFileCodec;
-import net.minecraft.world.level.WorldGenLevel;
-import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
-import org.apache.commons.lang3.mutable.MutableBoolean;
-
-public record PlacedFeature(Holder<ConfiguredFeature<?, ?>> feature, List<PlacementModifier> placement) {
-    public static final Codec<PlacedFeature> DIRECT_CODEC = RecordCodecBuilder.create((instance) -> {
-        return instance.group(ConfiguredFeature.CODEC.fieldOf("feature").forGetter((placedFeature) -> {
-            return placedFeature.feature;
-        }), PlacementModifier.CODEC.listOf().fieldOf("placement").forGetter((placedFeature) -> {
-            return placedFeature.placement;
-        })).apply(instance, PlacedFeature::new);
-    });
-    public static final Codec<Holder<PlacedFeature>> CODEC = RegistryFileCodec.create(Registry.PLACED_FEATURE_REGISTRY, DIRECT_CODEC);
-    public static final Codec<HolderSet<PlacedFeature>> LIST_CODEC = RegistryCodecs.homogeneousList(Registry.PLACED_FEATURE_REGISTRY, DIRECT_CODEC);
-    public static final Codec<List<HolderSet<PlacedFeature>>> LIST_OF_LISTS_CODEC = RegistryCodecs.homogeneousList(Registry.PLACED_FEATURE_REGISTRY, DIRECT_CODEC, true).listOf();
-
-    public boolean place(WorldGenLevel world, ChunkGenerator generator, Random random, BlockPos pos) {
-        return this.placeWithContext(new PlacementContext(world, generator, Optional.empty()), random, pos);
-    }
-
-    public boolean placeWithBiomeCheck(WorldGenLevel world, ChunkGenerator generator, Random random, BlockPos pos) {
-        return this.placeWithContext(new PlacementContext(world, generator, Optional.of(this)), random, pos);
-    }
-
-    private boolean placeWithContext(PlacementContext context, Random random, BlockPos pos) {
-        Stream<BlockPos> stream = Stream.of(pos);
-
-        for(PlacementModifier placementModifier : this.placement) {
-            stream = stream.flatMap((posx) -> {
-                return placementModifier.getPositions(context, random, posx);
-            });
-        }
-
-        ConfiguredFeature<?, ?> configuredFeature = this.feature.value();
-        MutableBoolean mutableBoolean = new MutableBoolean();
-        stream.forEach((blockPos) -> {
-            if (configuredFeature.place(context.getLevel(), context.generator(), random, blockPos)) {
-                mutableBoolean.setTrue();
-            }
-
-        });
-        return mutableBoolean.isTrue();
-    }
-
-    public Stream<ConfiguredFeature<?, ?>> getFeatures() {
-        return this.feature.value().getFeatures();
-    }
-
-    @Override
-    public String toString() {
-        return "Placed " + this.feature;
-    }
-
-    static record test(int a) {
-    }
-}
+package net.minecraft.world.level.levelgen.placement;
+
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import java.util.List;
+import java.util.Optional;
+import java.util.Random;
+import java.util.stream.Stream;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.HolderSet;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryCodecs;
+import net.minecraft.resources.RegistryFileCodec;
+import net.minecraft.world.level.WorldGenLevel;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import org.apache.commons.lang3.mutable.MutableBoolean;
+// Mirai start - c2me: worldgen vanilla bugs fixes
+import com.mojang.logging.LogUtils;
+import org.slf4j.Logger;
+// Mirai end
+
+public record PlacedFeature(Holder<ConfiguredFeature<?, ?>> feature, List<PlacementModifier> placement) {
+
+    private static final Logger LOGGER = LogUtils.getLogger(); // Mirai - c2me: worldgen vanilla bugs fixes
+
+    public static final Codec<PlacedFeature> DIRECT_CODEC = RecordCodecBuilder.create((instance) -> {
+        return instance.group(ConfiguredFeature.CODEC.fieldOf("feature").forGetter((placedFeature) -> {
+            return placedFeature.feature;
+        }), PlacementModifier.CODEC.listOf().fieldOf("placement").forGetter((placedFeature) -> {
+            return placedFeature.placement;
+        })).apply(instance, PlacedFeature::new);
+    });
+    public static final Codec<Holder<PlacedFeature>> CODEC = RegistryFileCodec.create(Registry.PLACED_FEATURE_REGISTRY, DIRECT_CODEC);
+    public static final Codec<HolderSet<PlacedFeature>> LIST_CODEC = RegistryCodecs.homogeneousList(Registry.PLACED_FEATURE_REGISTRY, DIRECT_CODEC);
+    public static final Codec<List<HolderSet<PlacedFeature>>> LIST_OF_LISTS_CODEC = RegistryCodecs.homogeneousList(Registry.PLACED_FEATURE_REGISTRY, DIRECT_CODEC, true).listOf();
+
+    public boolean place(WorldGenLevel world, ChunkGenerator generator, Random random, BlockPos pos) {
+        return this.placeWithContext(new PlacementContext(world, generator, Optional.empty()), random, pos);
+    }
+
+    public boolean placeWithBiomeCheck(WorldGenLevel world, ChunkGenerator generator, Random random, BlockPos pos) {
+        return this.placeWithContext(new PlacementContext(world, generator, Optional.of(this)), random, pos);
+    }
+
+    // Mirai start - c2me: worldgen vanilla bugs fixes
+    /**
+     * @author ishland
+     * @reason retry when stream fails
+     */
+    private boolean placeWithContext(PlacementContext context, Random random, BlockPos pos) {
+        Stream<BlockPos> stream;
+        for (int retries = 1; ; retries ++) {
+            try {
+                stream = Stream.of(pos);
+
+                for(PlacementModifier placementModifier : this.placement) {
+                    stream = stream.flatMap(posx -> placementModifier.getPositions(context, random, posx));
+                }
+
+                break;
+            } catch (IllegalStateException e) {
+                if (e.getMessage().equals("stream has already been operated upon or closed")) {
+                    if (retries == 3) {
+                        System.err.println("Retry failed, throwing exception");
+                        throw e;
+                    }
+                    System.err.println(String.format("Possible graalvm issue, retrying... (attempt %d)", retries + 1));
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        ConfiguredFeature<?, ?> configuredFeature = this.feature.value();
+        if (configuredFeature == null) {
+            LOGGER.error("NULL configuredFeature in PlacedFeature {}", this, new Throwable());
+            return false;
+        }
+        MutableBoolean placementModifier = new MutableBoolean();
+        stream.forEach(blockPos -> {
+            if (configuredFeature.place(context.getLevel(), context.generator(), random, blockPos)) {
+                placementModifier.setTrue();
+            }
+
+        });
+        return placementModifier.isTrue();
+    }
+
+    public Stream<ConfiguredFeature<?, ?>> getFeatures() {
+        return this.feature.value().getFeatures();
+    }
+
+    @Override
+    public String toString() {
+        return "Placed " + this.feature;
+    }
+
+    static record test(int a) {
+    }
+}
