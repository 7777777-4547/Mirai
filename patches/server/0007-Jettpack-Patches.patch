From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Etil <81570777+etil2jz@users.noreply.github.com>
Date: Sun, 24 Oct 2021 11:20:09 +0200
Subject: [PATCH] (Jettpack) Patches

Original code by Titaniumtown, licensed under GNU General Public License v3.0
You can find the original code on https://gitlab.com/Titaniumtown/JettPack

(Jettpack) Use LinkedBlockingDeque in IAsyncTaskHandler
(Jettpack) Better handling of async tasks
(Jettpack) Use MCUtil.asyncExecutor for MAIN_WORKER_EXECUTOR in SystemUtils

diff --git a/src/main/java/net/minecraft/Util.java b/src/main/java/net/minecraft/Util.java
index af598369e5aeae700d7d9da049f173fc51b7a370..850edad60a6677904487039d2977170d1a5fb11c 100644
--- a/src/main/java/net/minecraft/Util.java
+++ b/src/main/java/net/minecraft/Util.java
@@ -62,6 +62,11 @@ import net.minecraft.world.level.block.state.properties.Property;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import java.util.concurrent.AbstractExecutorService;
+import wtf.etil.mirai.server.util.ServerWorkerWrapper;
+import net.minecraft.server.MCUtil;
+import java.util.Collections;
+
 
 public class Util {
     private static final AtomicInteger WORKER_COUNT = new AtomicInteger(1);
@@ -139,7 +144,44 @@ public class Util {
         if (i <= 0) {
             executorService = MoreExecutors.newDirectExecutorService();
         } else {
-            executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new ServerWorkerThread(target, s, priorityModifier));
+            //executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new ServerWorkerThread(target, s, priorityModifier));
+			executorService = Integer.getInteger("Paper.WorkerThreadCount", i) <= 0 ? MoreExecutors.newDirectExecutorService() : new AbstractExecutorService(){
+				private volatile boolean shutdown = false;
+				
+				@Override
+				public final List<Runnable> shutdownNow() {
+					this.shutdown = true;
+					return Collections.emptyList();
+				}
+				
+				@Override
+                public final void shutdown() {
+                    this.shutdown = true;
+                }
+
+                @Override
+                public final boolean isShutdown() {
+                    return this.shutdown;
+                }
+
+                @Override
+                public final boolean isTerminated() {
+                    return this.shutdown;
+                }
+
+                @Override
+                public final boolean awaitTermination(long l2, TimeUnit timeUnit) throws InterruptedException {
+                    if (!this.shutdown) {
+                        throw new UnsupportedOperationException();
+                    }
+                    return true;
+                }
+
+                @Override
+                public final void execute(Runnable runnable) {
+                    MCUtil.asyncExecutor.execute(new ServerWorkerWrapper(runnable));
+                }
+            };
         }
         /*
                     @Override
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index b7c24a7ff4dc50d03f74b21a0b353d0ce559b4d4..065bd28349982bb7af97182c6cecff43c714bf65 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -350,9 +350,13 @@ public class Commands {
         // CraftBukkit start
         // Register Vanilla commands into builtRoot as before
         // Paper start - Async command map building
-        java.util.concurrent.ForkJoinPool.commonPool().execute(() -> {
-            sendAsync(player);
+        // Jettpack start
+		net.minecraft.server.MCUtil.smallAsyncTasks.add(new Runnable() {
+			public void run() {
+				sendAsync(player);
+			}
         });
+		// Jettpack end
     }
 
     private void sendAsync(ServerPlayer player) {
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index f9701ef4162868894a81f0d1ac9b58d00d9a2d65..3a81e1c901326abf15c7c000e8b0a03ffa722cb2 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -52,11 +52,14 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
+import java.util.concurrent.SynchronousQueue; // Jettpack
+import java.util.concurrent.ConcurrentLinkedQueue; // Jettpack
 
 public final class MCUtil {
+	public static final ConcurrentLinkedQueue smallAsyncTasks = new ConcurrentLinkedQueue(); // Jettpack
     public static final ThreadPoolExecutor asyncExecutor = new ThreadPoolExecutor(
-        0, 2, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>(),
+        4, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, // Jettpack
+		new SynchronousQueue<Runnable>(), // Jettpack
         new ThreadFactoryBuilder().setNameFormat("Paper Async Task Handler Thread - %1$d").build()
     );
     public static final ThreadPoolExecutor cleanerExecutor = new ThreadPoolExecutor(
@@ -67,6 +70,30 @@ public final class MCUtil {
 
     public static final long INVALID_CHUNK_KEY = getCoordinateKey(Integer.MAX_VALUE, Integer.MAX_VALUE);
 
+	// Jettpack start
+    public static void flushAsyncTasks() {
+        if (!smallAsyncTasks.isEmpty()) {
+            asyncExecutor.submit(() -> {
+            Runnable runnable;
+            while((runnable = (Runnable)smallAsyncTasks.poll()) != null) {
+                    runnable.run();
+                }
+            });
+        }
+    }
+
+    public static void flushAsyncTasksMidTick() {
+        if (smallAsyncTasks.size() <= 16) {
+            asyncExecutor.submit(() -> {
+                Runnable runnable;
+                while((runnable = (Runnable)smallAsyncTasks.poll()) != null) {
+                    runnable.run();
+                }
+
+            });
+        }
+    }
+    // Jettpack end
 
     public static Runnable once(Runnable run) {
         AtomicBoolean ran = new AtomicBoolean(false);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 31916c18ca01b6a47e1914d016e032587b55fd88..e5bc37ec44ba0225fa1a0cba6a62a7d22fd1e892 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -368,7 +368,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnab
             return;
         }
 
-        co.aikar.timings.MinecraftTimings.midTickChunkTasks.startTiming();
+        MCUtil.flushAsyncTasksMidTick();
+		co.aikar.timings.MinecraftTimings.midTickChunkTasks.startTiming();
         try {
             for (;;) {
                 boolean moreTasks = this.tickMidTickTasks();
@@ -1113,6 +1114,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnab
         LOGGER.info("Flushing Chunk IO");
         com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true, true); // Paper
         LOGGER.info("Closing Thread Pool");
+		MCUtil.flushAsyncTasks();
         Util.shutdownExecutors(); // Paper
         LOGGER.info("Closing Server");
         try {
@@ -1539,6 +1541,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnab
 
         // Paper start - move executeAll() into full server tick timing
         try (co.aikar.timings.Timing ignored = MinecraftTimings.processTasksTimer.startTiming()) {
+			MCUtil.flushAsyncTasks();
             this.runAllTasks();
         }
         // Paper end
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 5dd89126a7529277a89c6a9e914bb29032f709ff..0282b1082c104f18b548abd47e1745467874ad4c 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -46,6 +46,7 @@ import org.bukkit.event.player.AsyncPlayerPreLoginEvent;
 import org.bukkit.event.player.PlayerPreLoginEvent;
 // CraftBukkit end
 import io.netty.buffer.Unpooled; // Paper
+import net.minecraft.server.MCUtil;
 
 public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener {
 
@@ -126,7 +127,8 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener
 
     }
 
-    // Paper start - Cache authenticator threads
+    /*
+	// Paper start - Cache authenticator threads
     private static final AtomicInteger threadId = new AtomicInteger(0);
     private static final java.util.concurrent.ExecutorService authenticatorPool = java.util.concurrent.Executors.newCachedThreadPool(
             r -> {
@@ -138,6 +140,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener
             }
     );
     // Paper end
+	*/
     // Spigot start
     public void initUUID()
     {
@@ -247,7 +250,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener
             // Paper end
             // Spigot start
             // Paper start - Cache authenticator threads
-            authenticatorPool.execute(new Runnable() {
+            MCUtil.asyncExecutor.execute(new Runnable() { // Jettpack
                 @Override
                 public void run() {
                     try {
@@ -291,7 +294,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener
         }
 
         // Paper start - Cache authenticator threads
-        authenticatorPool.execute(new Runnable() {
+        MCUtil.asyncExecutor.execute(new Runnable() { // Jettpack
             public void run() {
                 GameProfile gameprofile = ServerLoginPacketListenerImpl.this.gameProfile;
 
@@ -425,7 +428,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener
             this.gameProfile = com.destroystokyo.paper.proxy.VelocityProxy.createProfile(buf);
 
             // Proceed with login
-            authenticatorPool.execute(() -> {
+            MCUtil.asyncExecutor.execute(() -> { // Jettpack
                 try {
                     new LoginHandler().fireEvents();
                 } catch (Exception ex) {
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 540aa5e12bb6b44d510c701f2867f541b07ebcc4..c43d9e277fc3a28af3b1a369f4f08164878f49a4 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -1,12 +1,12 @@
 package net.minecraft.util.thread;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Queues;
+//import com.google.common.collect.Queues; // Jettpack
 import java.util.List;
-import java.util.Queue;
+//import java.util.Queue; // Jettpack
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
-import java.util.concurrent.locks.LockSupport;
+//import java.util.concurrent.locks.LockSupport; // Jettpack
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
 import net.minecraft.util.profiling.metrics.MetricCategory;
@@ -15,12 +15,15 @@ import net.minecraft.util.profiling.metrics.MetricsRegistry;
 import net.minecraft.util.profiling.metrics.ProfilerMeasured;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import java.util.concurrent.LinkedBlockingDeque; // Jettpack
+import java.util.concurrent.TimeUnit; // Jettpack
 
 public abstract class BlockableEventLoop<R extends Runnable> implements ProfilerMeasured, ProcessorHandle<R>, Executor {
     private final String name;
     private static final Logger LOGGER = LogManager.getLogger();
-    private final Queue<R> pendingRunnables = Queues.newConcurrentLinkedQueue();
+    private final LinkedBlockingDeque<R> pendingRunnables = new LinkedBlockingDeque(); // Jettpack
     private int blockingCount;
+	private R next = null; // Jettpack
 
     protected BlockableEventLoop(String name) {
         this.name = name;
@@ -89,7 +92,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     @Override
     public void tell(R runnable) {
         this.pendingRunnables.add(runnable);
-        LockSupport.unpark(this.getRunningThread());
+        //LockSupport.unpark(this.getRunningThread()); // Jettpack
     }
 
     @Override
@@ -113,15 +116,20 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public boolean pollTask() {
-        R runnable = this.pendingRunnables.peek();
-        if (runnable == null) {
-            return false;
-        } else if (this.blockingCount == 0 && !true/*this.shouldRun(runnable)*/) { // Patina
+        // Jettpack start
+		if (this.next == null && !this.pendingRunnables.isEmpty()) {
+			this.waitForTasks();
+		}
+		
+		if (this.next == null) {
             return false;
         } else {
-            this.doRunTask(this.pendingRunnables.remove());
+            R r2 = this.next;
+			this.next = null;
+			this.doRunTask(r2);
             return true;
         }
+		// Jettpack end
     }
 
     public void managedBlock(BooleanSupplier stopCondition) {
@@ -140,8 +148,18 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     protected void waitForTasks() {
-        Thread.yield();
-        LockSupport.parkNanos("waiting for tasks", 100000L);
+        // Jettpack start
+		if (this.next != null) {
+			throw new IllegalStateException("next != null");
+		}
+		try {
+			this.next = this.pendingRunnables.poll(100L, TimeUnit.MICROSECONDS);
+			return;
+		}
+		catch (InterruptedException interruptedException) {
+			return;
+		}
+		// Jettpack end
     }
 
     protected void doRunTask(R task) {
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
index 3c1992e212a6d6f1db4d5b807b38d71913619fc0..ae78036292291f3fa0c4b7633608bdb699d47652 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
@@ -32,23 +32,30 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
+/*
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+*/
+import net.minecraft.server.MCUtil;
 
 public class CraftAsyncScheduler extends CraftScheduler {
 
-    private final ThreadPoolExecutor executor = new ThreadPoolExecutor(
+    /*
+	private final ThreadPoolExecutor executor = new ThreadPoolExecutor(
             4, Integer.MAX_VALUE,30L, TimeUnit.SECONDS, new SynchronousQueue<>(),
             new ThreadFactoryBuilder().setNameFormat("Craft Scheduler Thread - %1$d").build());
+	*/
     private final Executor management = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()
             .setNameFormat("Craft Async Scheduler Management Thread").build());
     private final List<CraftTask> temp = new ArrayList<>();
 
     CraftAsyncScheduler() {
         super(true);
+		/*
         executor.allowCoreThreadTimeOut(true);
         executor.prestartAllCoreThreads();
+		*/
     }
 
     @Override
@@ -93,7 +100,7 @@ public class CraftAsyncScheduler extends CraftScheduler {
     private boolean executeTask(CraftTask task) {
         if (isValid(task)) {
             this.runners.put(task.getTaskId(), task);
-            this.executor.execute(new ServerSchedulerReportingWrapper(task));
+            MCUtil.asyncExecutor.execute(new ServerSchedulerReportingWrapper(task)); // Jettpack
             return true;
         }
         return false;
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index bee38307494188800886a1622fed229b88dbd8f1..b3db65c1088888a8d6ae2395273239e8616a744a 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -141,6 +141,7 @@ public class WatchdogThread extends Thread
     {
         while ( !this.stopping )
         {
+			net.minecraft.server.MCUtil.flushAsyncTasks(); // Jettpack
             //
             // Paper start
             Logger log = Bukkit.getServer().getLogger();
diff --git a/src/main/java/wtf/etil/mirai/server/util/ServerWorkerWrapper.java b/src/main/java/wtf/etil/mirai/server/util/ServerWorkerWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..f13ed35d4a808667e6a3a58c285f5a1d9006d6bf
--- /dev/null
+++ b/src/main/java/wtf/etil/mirai/server/util/ServerWorkerWrapper.java
@@ -0,0 +1,24 @@
+package wtf.etil.mirai.server.util;
+
+import com.google.common.base.Preconditions;
+import net.minecraft.Util;
+
+public final class ServerWorkerWrapper implements Runnable {
+    private final Runnable internalRunnable;
+
+    public ServerWorkerWrapper(Runnable runnable) {
+        this.internalRunnable = Preconditions.checkNotNull(runnable, "internalRunnable");
+    }
+
+    @Override
+    public final void run() {
+        try {
+            this.internalRunnable.run();
+            return;
+        }
+        catch (Throwable throwable) {
+            Util.onThreadException(Thread.currentThread(), throwable);
+            return;
+        }
+    }
+}
